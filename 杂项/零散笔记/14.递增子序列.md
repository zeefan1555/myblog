# 1 491.递增子序列

[力扣题目链接](https://leetcode-cn.com/problems/increasing-subsequences/)

给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。

示例:

-   输入: [4, 6, 7, 7]
-   输出: [ [4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7] ]

说明:

-   给定数组的长度不会超过15。
-   数组中的整数范围是 [-100,100]。
-   给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。




```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```
# 2 回溯三部曲

定义一些变量
path；result
## 2.1 确定回溯函数参数返回值(void)
求子序列，一个元素不能重复使用，用**startIndex**调整下一层递归的起始条件
## 2.2 终止条件, 存放结果, return
![[回溯求子集问题]]
但本题收集结果有所不同，题目要求递增子序列大小至少为2，

```cpp
if (path.size() > 1) {
    result.push_back(path);
    // 注意这里不要加return，因为要取树上的所有节点
}
```
## 2.3 单层搜索过程
![[14.递增子序列 2022-05-24 10.48.11.excalidraw]]

![491. 递增子序列1|800](https://img-blog.csdnimg.cn/20201124200229824.png)
**同一父节点下的同层上使用过的元素就不能在使用了**

同一层相同的数字不能重复用
小于上一层的数字，后边的也不用


在[[13.子集 II]]中我们是通过排序，再加一个标记数组来达到去重的目的。

而本题求自增子序列，是不能对原数组经行排序的，要求的子序列是原本数组中的顺序
	本题不能排序，自然无法用startIndex来判断位置了


[[14.递增子序列(自写)]]

#疑问 