去重问题：[[8.组合总和II]]，[[13.子集 II]]

去重需要先对集合排序

树层去重：重点
1.前一个元素和后一个元素数值相同 + 2.两个元素位置不同则去重
	num[i] == num[i-1]; 
	位置不同：用startIndex与i 比较，或者用used数组
		 **用startIndex判断位置不同**：eg ：backtracking(... , i+1)，不使用used数组来去重，因为递归的时候下一个startIndex是i+1而不是0。
			 用了startIndex就跳过了第一个元素了，排列问题不可用
		**用used数组判断位置不同**：eg：backtracking(... , 0)，因为如果要是全排列的话，每次要从0开始遍历，为了跳过已入栈的元素，需要使用used。
			排列问题用used数组，因为每层从0开始而不是startIndex
			需要used数组记录path里都放了哪些元素了


树枝去重

如果要对**树层中前一位去重**，就用`used[i - 1] == false`，如果要对树**枝前一位去重**用`used[i - 1] == true`。

**对于排列问题，树层上去重和树枝上去重，都是可以的，但是树层上去重效率更高！**