# 1 78.子集

[力扣题目链接](https://leetcode-cn.com/problems/subsets/)

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。

说明：解集不能包含重复的子集。

示例: 输入: nums = [1,2,3] 输出: [ [3],   [1],   [2],   [1,2,3],   [1,3],   [2,3],   [1,2],   [] ]

# 2 思路
**求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树**。
**组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！**
**[[startIndex]]
**以示例中nums = [1,2,3]为例把求子集抽象为树型结构，如下：

![78.子集](https://img-blog.csdnimg.cn/202011232041348.png)
**遍历这个树的时候，把所有节点都记录下来，就是要求的子集集合**。



```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```
# 3 回溯三部曲

定义一些变量
path；result
## 3.1 确定回溯函数参数返回值(void)
startIndex：控制for循环下一层的起始位置
## 3.2 终止条件, 存放结果, return
剩余集合为空的时候，就是叶子节点。
startIndex已经大于数组的长度了，就终止了，因为没有元素可取了，代码如下:
eg：startIndex = 3， nums.size() = 2，起始位置已经超过了nums的长度当然不行了

```cpp
if (startIndex >= nums.size()) {
    return;
}
```
## 3.3 单层搜索过程
子集收集元素
递归
弹出回溯j
**for循环横向遍历，递归纵向遍历，回溯不断调整结果集**

[[11.子集问题(自写)]]

