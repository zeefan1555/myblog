# 1 93.复原IP地址

[力扣题目链接](https://leetcode-cn.com/problems/restore-ip-addresses/)

给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。

有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，**且不能含有前导 0**），整数之间用 '.' 分隔。

例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，但是 "0.**011**.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。

示例 1：

-   输入：s = "25525511135"
-   输出：["255.255.11.135","255.255.111.35"]

示例 2：

-   输入：s = "0000"
-   输出：["0.0.0.0"]

示例 3：

-   输入：s = "1111"
-   输出：["1.1.1.1"]

示例 4：

-   输入：s = "010010"
-   输出：["0.10.0.10","0.100.1.0"]

示例 5：

-   输入：s = "101023"
-   输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]

提示：

-   0 <= s.length <= 3000
-   s 仅由数字组成

# 2 思路

切割问题：**切割问题就可以使用回溯搜索法把所有可能性搜出来**
![93.复原IP地址](https://img-blog.csdnimg.cn/20201123203735933.png)

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```
# 3 回溯三部曲

定义一些变量
path，result
## 3.1 确定回溯函数参数返回值(void)
startIndex：控制不能重复切割
pointNum：记录逗点的数量
```cpp
vector<string> result;// 记录结果
// startIndex: 搜索的起始位置，pointNum:添加逗点的数量
void backtracking(string& s, int startIndex, int pointNum) {
```
## 3.2 终止条件, 存放结果, return
本题明确要求只会分成4段，所以不能用切割线切到最后作为终止条件，而是分割的段数作为终止条件pointNum表示逗点数量，pointNum为3说明字符串分成了4段了。然后验证一下第四段是否合法，如果合法就加入到结果集里
	```
	if (pointNum == 3) { // 逗点数量为3时，分隔结束
	    // 判断第四段子字符串是否合法，如果合法就放进result中
	    if (isValid(s, startIndex, s.size() - 1)) {
	        result.push_back(s);
	    }
	    return;
	}
	```
## 3.3 单层搜索过程
截取子串
	`for (int i = startIndex; i < s.size(); i++)`循环中 [startIndex, i] 这个区间就是截取的子串，
判断子串是否合法，如果合法就在字符串后面加上符号`.`表示已经分割。如果不合法就结束本层循环，如图中剪掉的分支
```col
![[Pasted image 20220520111825.png]]

判断子串是否合法：
主要考虑到如下三点：
-   段位以0为开头的数字不合法
-   段位里有非正整数字符不合法
-   段位如果大于255了不合法
```



[[10.复制IP地址(carl：0.0.0.0版).mp4]]
[[10.复制IP地址(carl：255版)..mp4]]