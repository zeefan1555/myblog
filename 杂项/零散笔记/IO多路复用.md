---
id: d91631cc-5031-4d5e-a516-78ac2e14d93f
---
[margin](marginnote3app://note/145A1C77-D798-4681-8AAE-0BD2FA6AD727)
I/O 多路复用使得程序能同时监听多个文件描述符,能够提高程序的性能,
Linux 下实现 I/O 多路复用的系统调用主要有 select、poll 和 epoll。

I：输入，从文件当中把数据写入内存
O: 输出，把内存的数据读到文件里去

I/O 操作相当于对socket的缓冲区的操作

多路复用：多条路复用成一条

#flashcards/webserver 
阻塞等待
?
快递员到了之后人才能拿快递。快递没来，人就被阻塞在那里了。
 典型函数：read(没有数据发过来就一直阻塞)，accpet(没有客户连接进来就一直阻塞)
 ![[Pasted image 20220525163044.png|600]]
解决办法：搞出分身去解决(多线程，多进程)去收发各个快递
![[Pasted image 20220525163347.png|600]]
阻塞等待的模型： BIO模型
[margin](marginnote3app://note/71666D96-F61F-43AE-9FC9-F7BC4206964A)
![[705a8cd54a58a4c1cd913f74ceb539d0.png|725]]
服务端创建socket，绑定IP和端口→监听→接受连接
如果只是一个进程，那么多个客户端来连接就会阻塞。
解决办法是：创建多线程来进行连接。accept前面应当有while循环
<!--SR:!2022-05-28,3,250-->


非阻塞，忙轮询
?
[](marginnote3app://note/2D2CF553-A636-45BD-B61E-CA006C1D2812)
![[eb409ec1df657b8f2d1c348b4250884c.png|725]]
假设read没读到数据，让while循环一直让read函数去读取读缓冲区的数据
<!--SR:!2022-05-28,3,250-->




NIO模型
?
![[Pasted image 20220525170732.png|725]]
用一个while循环套accpet，用一个while循环套read，
让他俩不断循环的看有没有客户端连接进来，有没有数据写入了读缓冲区。
缺点：如果是1万个客户端想连接，就要循环1万次
如果1万客户端都连接了，其中只有一个客户端有数据发送过来，循环read函数9999次都是无效的
<!--SR:!2022-05-28,3,250-->


select/poll/epoll 简单原理
?
![[Pasted image 20220525172029.png|725]]
但不告诉你是哪几个快递
![[Pasted image 20220525172311.png|725]]
多路复用的意思：之前有100个客户端，检测有无数据就要调用100次的read函数，
现在我用一个文件描述符表来委托内核来检测，在统一返回一个文件描述表。
这样100路就变成了1路(简称多路复用)
<!--SR:!2022-05-28,3,250-->
