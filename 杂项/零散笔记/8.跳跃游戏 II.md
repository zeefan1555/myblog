# 1 45.跳跃游戏II

[力扣题目链接](https://leetcode-cn.com/problems/jump-game-ii/)


给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

示例:

-   输入: [2,3,1,1,4]
-   输出: 2
-   解释: 跳到最后一个位置的最小跳跃数是 2。从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。

说明: 假设你总是可以到达数组的最后一个位置。

# 2 思路
计算最小步数
其实是看最大覆盖范围
局部最优：尽可能多走，没法走了，就在走一步
全局最优：一步尽可能多走，从而达到最小步数


**以最小的步数增加最大的覆盖范围，直到覆盖范围覆盖了终点**，
**统计两个覆盖范围，当前这一步的最大覆盖和下一步最大覆盖**。
如果移动下标达到了当前这一步的最大覆盖最远距离了，还没有到终点的话，
那么就必须再走一步来增加覆盖范围，直到覆盖范围覆盖了终点。
![45.跳跃游戏II|550](https://img-blog.csdnimg.cn/20201201232309103.png)
**图中覆盖范围的意义在于，只要红色的区域，最多两步一定可以到！**


-   如果当前覆盖最远距离下标不是是集合终点，步数就加一，还需要继续走。
-   如果当前覆盖最远距离下标就是是集合终点，步数不用加一，因为不能再往后走了。

# 3 代码
[[8.跳跃游戏 II(carl).mp4]]


[参考原理](https://www.bilibili.com/video/BV1SA41147aU?spm_id_from=333.337.search-card.all.click)

错误示范
![](https://s1.vika.cn/space/2022/05/31/7ffc2c659dbe428eb15c890eaa21c89d)


if(prop("已完成任务数") / prop("总任务数") >= 1, "☑️", slice("✦✦✦✦✦✦✦✦✦✦", 0, floor(prop("已完成任务数") / prop("总任务数") * 10)) + slice("✧✧✧✧✧✧✧✧✧✧", 0, ceil(10 - prop("已完成任务数") / prop("总任务数") * 10)) + " " + format(round(prop("已完成任务数") / prop("总任务数") * 100)) + "%")