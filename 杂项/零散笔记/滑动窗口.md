服务器端根据设置一个接受数据的尺寸来控制客户端的发送
TCP 中采用滑动窗口来进行传输控制,滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时,发送方一般不能再发送数据报。
滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构。

窗口理解为缓冲区的大小
滑动窗口的大小会随着发送数据和接收数据而变化。
通信的双方都有发送缓冲区和接收数据的缓冲区
服务器：
发送缓冲区（发送缓冲区的窗口）
接收缓冲区（接收缓冲区的窗口）
客户端：  

发送缓冲区（发送缓冲区的窗口）
接收缓冲区（接收缓冲区的窗口）

![[Pasted image 20220520164119.png]]
>这个可以不看，看下边的实例就行

# 1 滑动窗口实例
>mss：maximum segment size (一条数据的最大数据量) 。eg：<mss 1460> 一次最多可发送1460字节的数量的数据
>win：滑动窗口尺寸。eg：win 4096 (客户端/服务端 滑动窗口尺寸为4096)
>0(0)：随机序号seq(发送的数据量)


## 1.1 滑动窗口图解

![[b410e87074b018768803fa755cf0a49d.png]][](marginnote3app://note/DC538902-F13D-465E-AE98-019FC531D786)

1. 客户端向服务器发起连接，客户端的滑动窗口是4096，一次发送的最大数据量是1460
2. 服务器接收连接请求ack = seq + 数据量 + SYN(1个字节)，ack = 1(表示对SYN的确认，此时没有数据) ，告诉客户端服务器的窗口大小是6144，一次发送的最大数据量是1024
3. 第三次握手
4. 4-9 客户端连续给服务器发送了6k的数据，每次发送1k
5. 第10次，服务器告诉客户端：发送的6k数据以及接收到，存储在缓冲区中，缓冲区数据己经处理了2k，窗口大小是2k
6. 第11次，服务器告诉客户端：发送的6k数据以及接收到，存储在缓冲区中，缓冲区数据已经处理了4k，窗口大小是4k
7. 第12次，客户端又给服务器发送了1k的数据
8. 第13次，客户端主动请求和服务器断开连接，并且给服务器发送了1k的数据   ^fyk6mo
9. 第14次，服务器回复ack 8194 ，win 2048  
	1. 同意断开连接的请求+告诉客户端己经接受到方才发的2k的数据 
		1. ack = seq + 数据量 + FIN(1个字节)
			1. 上次是7169(1024)，多一个字节是因为对FIN的确认
		2. 客户端发送FIN也是可以携带数据的，因为此时还处于互相连接的状态
	2. 滑动窗口2k
10. 第15、16次，通知客户端滑动窗口的大小
11. 第17次，第三次挥手，服务器端给客户端发送 TN,请求断开连接
12. 第18次，第四次回收，客户端同意了服务器端的断开请求

