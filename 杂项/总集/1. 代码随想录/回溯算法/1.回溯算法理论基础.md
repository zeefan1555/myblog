[[代码随想录.回溯算法]]

**组合是不强调元素顺序的，排列是强调元素顺序**：==组合无序，排列有序==
{1, 2} 和 {2, 1}：组合是一样的，排列是不一样的

# 1 回溯法能解决的问题
回溯法能解决n层for循环的问题

回溯算法能解决如下问题：

-   组合问题：N个数里面按一定规则找出k个数的集合
	- [[2.组合问题]] [[4.组合总和III]] [[5.电话号码的字母组合]]

-   排列问题：N个数按一定规则全排列，有几种排列方式
-   切割问题：一个字符串按一定规则有几种切割方式
-   子集问题：一个N个数的集合里有多少符合条件的子集
-   棋盘问题：N皇后，解数独等等
- 
把回溯法抽象为一个图形，每一道回溯法的题目都可以抽象为树形结构。

# 2 回溯三部曲：
## 2.1 回溯函数模板返回值以及参数.
```cpp
void backtracking(参数)
```

## 2.2 回溯函数终止条件
	终止条件：一般来说搜到叶子节点了，也就找到了满足条件的一条答案，把这个答案存放起来，并结束本层递归。
```cpp
if (终止条件) {
    存放结果;
    return;// 结束本轮递归开始回溯
}
```

## 2.3 回溯搜索的遍历过程
回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。
![回溯算法理论基础](https://img-blog.csdnimg.cn/20210130173631174.png)

回溯函数遍历过程伪代码如下：
	 **for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。**
```cpp
for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
    处理节点;
    backtracking(路径，选择列表); // 递归
    回溯，撤销处理结果
}
```

回溯算法模板框架
```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```